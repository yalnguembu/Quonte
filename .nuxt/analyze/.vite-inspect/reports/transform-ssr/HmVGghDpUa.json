{
  "resolvedId": "/home/yalnguembu/Perso/quonte/services/core/request.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/* generated using openapi-typescript-codegen -- do not edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport axios from 'axios';\nimport type { AxiosError, AxiosRequestConfig, AxiosResponse, AxiosInstance } from 'axios';\nimport FormData from 'form-data';\n\nimport { ApiError } from './ApiError';\nimport type { ApiRequestOptions } from './ApiRequestOptions';\nimport type { ApiResult } from './ApiResult';\nimport { CancelablePromise } from './CancelablePromise';\nimport type { OnCancel } from './CancelablePromise';\nimport type { OpenAPIConfig } from './OpenAPI';\n\nexport const isDefined = <T>(value: T | null | undefined): value is Exclude<T, null | undefined> => {\n    return value !== undefined && value !== null;\n};\n\nexport const isString = (value: any): value is string => {\n    return typeof value === 'string';\n};\n\nexport const isStringWithValue = (value: any): value is string => {\n    return isString(value) && value !== '';\n};\n\nexport const isBlob = (value: any): value is Blob => {\n    return (\n        typeof value === 'object' &&\n        typeof value.type === 'string' &&\n        typeof value.stream === 'function' &&\n        typeof value.arrayBuffer === 'function' &&\n        typeof value.constructor === 'function' &&\n        typeof value.constructor.name === 'string' &&\n        /^(Blob|File)$/.test(value.constructor.name) &&\n        /^(Blob|File)$/.test(value[Symbol.toStringTag])\n    );\n};\n\nexport const isFormData = (value: any): value is FormData => {\n    return value instanceof FormData;\n};\n\nexport const isSuccess = (status: number): boolean => {\n    return status >= 200 && status < 300;\n};\n\nexport const base64 = (str: string): string => {\n    try {\n        return btoa(str);\n    } catch (err) {\n        // @ts-ignore\n        return Buffer.from(str).toString('base64');\n    }\n};\n\nexport const getQueryString = (params: Record<string, any>): string => {\n    const qs: string[] = [];\n\n    const append = (key: string, value: any) => {\n        qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);\n    };\n\n    const process = (key: string, value: any) => {\n        if (isDefined(value)) {\n            if (Array.isArray(value)) {\n                value.forEach(v => {\n                    process(key, v);\n                });\n            } else if (typeof value === 'object') {\n                Object.entries(value).forEach(([k, v]) => {\n                    process(`${key}[${k}]`, v);\n                });\n            } else {\n                append(key, value);\n            }\n        }\n    };\n\n    Object.entries(params).forEach(([key, value]) => {\n        process(key, value);\n    });\n\n    if (qs.length > 0) {\n        return `?${qs.join('&')}`;\n    }\n\n    return '';\n};\n\nconst getUrl = (config: OpenAPIConfig, options: ApiRequestOptions): string => {\n    const encoder = config.ENCODE_PATH || encodeURI;\n\n    const path = options.url\n        .replace('{api-version}', config.VERSION)\n        .replace(/{(.*?)}/g, (substring: string, group: string) => {\n            if (options.path?.hasOwnProperty(group)) {\n                return encoder(String(options.path[group]));\n            }\n            return substring;\n        });\n\n    const url = `${config.BASE}${path}`;\n    if (options.query) {\n        return `${url}${getQueryString(options.query)}`;\n    }\n    return url;\n};\n\nexport const getFormData = (options: ApiRequestOptions): FormData | undefined => {\n    if (options.formData) {\n        const formData = new FormData();\n\n        const process = (key: string, value: any) => {\n            if (isString(value) || isBlob(value)) {\n                formData.append(key, value);\n            } else {\n                formData.append(key, JSON.stringify(value));\n            }\n        };\n\n        Object.entries(options.formData)\n            .filter(([_, value]) => isDefined(value))\n            .forEach(([key, value]) => {\n                if (Array.isArray(value)) {\n                    value.forEach(v => process(key, v));\n                } else {\n                    process(key, value);\n                }\n            });\n\n        return formData;\n    }\n    return undefined;\n};\n\ntype Resolver<T> = (options: ApiRequestOptions) => Promise<T>;\n\nexport const resolve = async <T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> => {\n    if (typeof resolver === 'function') {\n        return (resolver as Resolver<T>)(options);\n    }\n    return resolver;\n};\n\nexport const getHeaders = async (config: OpenAPIConfig, options: ApiRequestOptions, formData?: FormData): Promise<Record<string, string>> => {\n    const [token, username, password, additionalHeaders] = await Promise.all([\n        resolve(options, config.TOKEN),\n        resolve(options, config.USERNAME),\n        resolve(options, config.PASSWORD),\n        resolve(options, config.HEADERS),\n    ]);\n\n    const formHeaders = typeof formData?.getHeaders === 'function' && formData?.getHeaders() || {}\n\n    const headers = Object.entries({\n        Accept: 'application/json',\n        ...additionalHeaders,\n        ...options.headers,\n        ...formHeaders,\n    })\n    .filter(([_, value]) => isDefined(value))\n    .reduce((headers, [key, value]) => ({\n        ...headers,\n        [key]: String(value),\n    }), {} as Record<string, string>);\n\n    if (isStringWithValue(token)) {\n        headers['Authorization'] = `Bearer ${token}`;\n    }\n\n    if (isStringWithValue(username) && isStringWithValue(password)) {\n        const credentials = base64(`${username}:${password}`);\n        headers['Authorization'] = `Basic ${credentials}`;\n    }\n\n    if (options.body !== undefined) {\n        if (options.mediaType) {\n            headers['Content-Type'] = options.mediaType;\n        } else if (isBlob(options.body)) {\n            headers['Content-Type'] = options.body.type || 'application/octet-stream';\n        } else if (isString(options.body)) {\n            headers['Content-Type'] = 'text/plain';\n        } else if (!isFormData(options.body)) {\n            headers['Content-Type'] = 'application/json';\n        }\n    }\n\n    return headers;\n};\n\nexport const getRequestBody = (options: ApiRequestOptions): any => {\n    if (options.body) {\n        return options.body;\n    }\n    return undefined;\n};\n\nexport const sendRequest = async <T>(\n    config: OpenAPIConfig,\n    options: ApiRequestOptions,\n    url: string,\n    body: any,\n    formData: FormData | undefined,\n    headers: Record<string, string>,\n    onCancel: OnCancel,\n    axiosClient: AxiosInstance\n): Promise<AxiosResponse<T>> => {\n    const source = axios.CancelToken.source();\n\n    const requestConfig: AxiosRequestConfig = {\n        url,\n        headers,\n        data: body ?? formData,\n        method: options.method,\n        withCredentials: config.WITH_CREDENTIALS,\n        withXSRFToken: config.CREDENTIALS === 'include' ? config.WITH_CREDENTIALS : false,\n        cancelToken: source.token,\n    };\n\n    onCancel(() => source.cancel('The user aborted a request.'));\n\n    try {\n        return await axiosClient.request(requestConfig);\n    } catch (error) {\n        const axiosError = error as AxiosError<T>;\n        if (axiosError.response) {\n            return axiosError.response;\n        }\n        throw error;\n    }\n};\n\nexport const getResponseHeader = (response: AxiosResponse<any>, responseHeader?: string): string | undefined => {\n    if (responseHeader) {\n        const content = response.headers[responseHeader];\n        if (isString(content)) {\n            return content;\n        }\n    }\n    return undefined;\n};\n\nexport const getResponseBody = (response: AxiosResponse<any>): any => {\n    if (response.status !== 204) {\n        return response.data;\n    }\n    return undefined;\n};\n\nexport const catchErrorCodes = (options: ApiRequestOptions, result: ApiResult): void => {\n    const errors: Record<number, string> = {\n        400: 'Bad Request',\n        401: 'Unauthorized',\n        403: 'Forbidden',\n        404: 'Not Found',\n        500: 'Internal Server Error',\n        502: 'Bad Gateway',\n        503: 'Service Unavailable',\n        ...options.errors,\n    }\n\n    const error = errors[result.status];\n    if (error) {\n        throw new ApiError(options, result, error);\n    }\n\n    if (!result.ok) {\n        const errorStatus = result.status ?? 'unknown';\n        const errorStatusText = result.statusText ?? 'unknown';\n        const errorBody = (() => {\n            try {\n                return JSON.stringify(result.body, null, 2);\n            } catch (e) {\n                return undefined;\n            }\n        })();\n\n        throw new ApiError(options, result,\n            `Generic Error: status: ${errorStatus}; status text: ${errorStatusText}; body: ${errorBody}`\n        );\n    }\n};\n\n/**\n * Request method\n * @param config The OpenAPI configuration object\n * @param options The request options from the service\n * @param axiosClient The axios client instance to use\n * @returns CancelablePromise<T>\n * @throws ApiError\n */\nexport const request = <T>(config: OpenAPIConfig, options: ApiRequestOptions, axiosClient: AxiosInstance = axios): CancelablePromise<T> => {\n    return new CancelablePromise(async (resolve, reject, onCancel) => {\n        try {\n            const url = getUrl(config, options);\n            const formData = getFormData(options);\n            const body = getRequestBody(options);\n            const headers = await getHeaders(config, options, formData);\n\n            if (!onCancel.isCancelled) {\n                const response = await sendRequest<T>(config, options, url, body, formData, headers, onCancel, axiosClient);\n                const responseBody = getResponseBody(response);\n                const responseHeader = getResponseHeader(response, options.responseHeader);\n\n                const result: ApiResult = {\n                    url,\n                    ok: isSuccess(response.status),\n                    status: response.status,\n                    statusText: response.statusText,\n                    body: responseHeader ?? responseBody,\n                };\n\n                catchErrorCodes(options, result);\n\n                resolve(result.body);\n            }\n        } catch (error) {\n            reject(error);\n        }\n    });\n};\n",
      "start": 1713208780227,
      "end": 1713208780249,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1713208780249,
      "end": 1713208780249,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1713208780249,
      "end": 1713208780249,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1713208780249,
      "end": 1713208780249,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1713208780249,
      "end": 1713208780249,
      "order": "pre"
    },
    {
      "name": "unplugin-vue-i18n",
      "start": 1713208780249,
      "end": 1713208780249,
      "order": "pre"
    },
    {
      "name": "unplugin-vue-i18n",
      "start": 1713208780249,
      "end": 1713208780249,
      "order": "pre"
    },
    {
      "name": "nuxtjs:i18n-macros-transform",
      "start": 1713208780249,
      "end": 1713208780249,
      "order": "pre"
    },
    {
      "name": "nuxtjs:i18n-macros-transform",
      "start": 1713208780249,
      "end": 1713208780249,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1713208780249,
      "end": 1713208780249,
      "order": "pre"
    },
    {
      "name": "server-only-component-transform",
      "start": 1713208780249,
      "end": 1713208780249,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1713208780249,
      "end": 1713208780249,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "result": "import axios from \"axios\";\nimport FormData from \"form-data\";\nimport { ApiError } from \"./ApiError\";\nimport { CancelablePromise } from \"./CancelablePromise\";\nexport const isDefined = (value) => {\n  return value !== void 0 && value !== null;\n};\nexport const isString = (value) => {\n  return typeof value === \"string\";\n};\nexport const isStringWithValue = (value) => {\n  return isString(value) && value !== \"\";\n};\nexport const isBlob = (value) => {\n  return typeof value === \"object\" && typeof value.type === \"string\" && typeof value.stream === \"function\" && typeof value.arrayBuffer === \"function\" && typeof value.constructor === \"function\" && typeof value.constructor.name === \"string\" && /^(Blob|File)$/.test(value.constructor.name) && /^(Blob|File)$/.test(value[Symbol.toStringTag]);\n};\nexport const isFormData = (value) => {\n  return value instanceof FormData;\n};\nexport const isSuccess = (status) => {\n  return status >= 200 && status < 300;\n};\nexport const base64 = (str) => {\n  try {\n    return btoa(str);\n  } catch (err) {\n    return Buffer.from(str).toString(\"base64\");\n  }\n};\nexport const getQueryString = (params) => {\n  const qs = [];\n  const append = (key, value) => {\n    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);\n  };\n  const process = (key, value) => {\n    if (isDefined(value)) {\n      if (Array.isArray(value)) {\n        value.forEach((v) => {\n          process(key, v);\n        });\n      } else if (typeof value === \"object\") {\n        Object.entries(value).forEach(([k, v]) => {\n          process(`${key}[${k}]`, v);\n        });\n      } else {\n        append(key, value);\n      }\n    }\n  };\n  Object.entries(params).forEach(([key, value]) => {\n    process(key, value);\n  });\n  if (qs.length > 0) {\n    return `?${qs.join(\"&\")}`;\n  }\n  return \"\";\n};\nconst getUrl = (config, options) => {\n  const encoder = config.ENCODE_PATH || encodeURI;\n  const path = options.url.replace(\"{api-version}\", config.VERSION).replace(/{(.*?)}/g, (substring, group) => {\n    if (options.path?.hasOwnProperty(group)) {\n      return encoder(String(options.path[group]));\n    }\n    return substring;\n  });\n  const url = `${config.BASE}${path}`;\n  if (options.query) {\n    return `${url}${getQueryString(options.query)}`;\n  }\n  return url;\n};\nexport const getFormData = (options) => {\n  if (options.formData) {\n    const formData = new FormData();\n    const process = (key, value) => {\n      if (isString(value) || isBlob(value)) {\n        formData.append(key, value);\n      } else {\n        formData.append(key, JSON.stringify(value));\n      }\n    };\n    Object.entries(options.formData).filter(([_, value]) => isDefined(value)).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        value.forEach((v) => process(key, v));\n      } else {\n        process(key, value);\n      }\n    });\n    return formData;\n  }\n  return void 0;\n};\nexport const resolve = async (options, resolver) => {\n  if (typeof resolver === \"function\") {\n    return resolver(options);\n  }\n  return resolver;\n};\nexport const getHeaders = async (config, options, formData) => {\n  const [token, username, password, additionalHeaders] = await Promise.all([\n    resolve(options, config.TOKEN),\n    resolve(options, config.USERNAME),\n    resolve(options, config.PASSWORD),\n    resolve(options, config.HEADERS)\n  ]);\n  const formHeaders = typeof formData?.getHeaders === \"function\" && formData?.getHeaders() || {};\n  const headers = Object.entries({\n    Accept: \"application/json\",\n    ...additionalHeaders,\n    ...options.headers,\n    ...formHeaders\n  }).filter(([_, value]) => isDefined(value)).reduce((headers2, [key, value]) => ({\n    ...headers2,\n    [key]: String(value)\n  }), {});\n  if (isStringWithValue(token)) {\n    headers[\"Authorization\"] = `Bearer ${token}`;\n  }\n  if (isStringWithValue(username) && isStringWithValue(password)) {\n    const credentials = base64(`${username}:${password}`);\n    headers[\"Authorization\"] = `Basic ${credentials}`;\n  }\n  if (options.body !== void 0) {\n    if (options.mediaType) {\n      headers[\"Content-Type\"] = options.mediaType;\n    } else if (isBlob(options.body)) {\n      headers[\"Content-Type\"] = options.body.type || \"application/octet-stream\";\n    } else if (isString(options.body)) {\n      headers[\"Content-Type\"] = \"text/plain\";\n    } else if (!isFormData(options.body)) {\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n  }\n  return headers;\n};\nexport const getRequestBody = (options) => {\n  if (options.body) {\n    return options.body;\n  }\n  return void 0;\n};\nexport const sendRequest = async (config, options, url, body, formData, headers, onCancel, axiosClient) => {\n  const source = axios.CancelToken.source();\n  const requestConfig = {\n    url,\n    headers,\n    data: body ?? formData,\n    method: options.method,\n    withCredentials: config.WITH_CREDENTIALS,\n    withXSRFToken: config.CREDENTIALS === \"include\" ? config.WITH_CREDENTIALS : false,\n    cancelToken: source.token\n  };\n  onCancel(() => source.cancel(\"The user aborted a request.\"));\n  try {\n    return await axiosClient.request(requestConfig);\n  } catch (error) {\n    const axiosError = error;\n    if (axiosError.response) {\n      return axiosError.response;\n    }\n    throw error;\n  }\n};\nexport const getResponseHeader = (response, responseHeader) => {\n  if (responseHeader) {\n    const content = response.headers[responseHeader];\n    if (isString(content)) {\n      return content;\n    }\n  }\n  return void 0;\n};\nexport const getResponseBody = (response) => {\n  if (response.status !== 204) {\n    return response.data;\n  }\n  return void 0;\n};\nexport const catchErrorCodes = (options, result) => {\n  const errors = {\n    400: \"Bad Request\",\n    401: \"Unauthorized\",\n    403: \"Forbidden\",\n    404: \"Not Found\",\n    500: \"Internal Server Error\",\n    502: \"Bad Gateway\",\n    503: \"Service Unavailable\",\n    ...options.errors\n  };\n  const error = errors[result.status];\n  if (error) {\n    throw new ApiError(options, result, error);\n  }\n  if (!result.ok) {\n    const errorStatus = result.status ?? \"unknown\";\n    const errorStatusText = result.statusText ?? \"unknown\";\n    const errorBody = (() => {\n      try {\n        return JSON.stringify(result.body, null, 2);\n      } catch (e) {\n        return void 0;\n      }\n    })();\n    throw new ApiError(\n      options,\n      result,\n      `Generic Error: status: ${errorStatus}; status text: ${errorStatusText}; body: ${errorBody}`\n    );\n  }\n};\nexport const request = (config, options, axiosClient = axios) => {\n  return new CancelablePromise(async (resolve2, reject, onCancel) => {\n    try {\n      const url = getUrl(config, options);\n      const formData = getFormData(options);\n      const body = getRequestBody(options);\n      const headers = await getHeaders(config, options, formData);\n      if (!onCancel.isCancelled) {\n        const response = await sendRequest(config, options, url, body, formData, headers, onCancel, axiosClient);\n        const responseBody = getResponseBody(response);\n        const responseHeader = getResponseHeader(response, options.responseHeader);\n        const result = {\n          url,\n          ok: isSuccess(response.status),\n          status: response.status,\n          statusText: response.statusText,\n          body: responseHeader ?? responseBody\n        };\n        catchErrorCodes(options, result);\n        resolve2(result.body);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\n",
      "start": 1713208780249,
      "end": 1713208780263,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "/home/yalnguembu/Perso/quonte/services/core/request.ts"
        ],
        "sourcesContent": [
          "/* generated using openapi-typescript-codegen -- do not edit */\n/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport axios from 'axios';\nimport type { AxiosError, AxiosRequestConfig, AxiosResponse, AxiosInstance } from 'axios';\nimport FormData from 'form-data';\n\nimport { ApiError } from './ApiError';\nimport type { ApiRequestOptions } from './ApiRequestOptions';\nimport type { ApiResult } from './ApiResult';\nimport { CancelablePromise } from './CancelablePromise';\nimport type { OnCancel } from './CancelablePromise';\nimport type { OpenAPIConfig } from './OpenAPI';\n\nexport const isDefined = <T>(value: T | null | undefined): value is Exclude<T, null | undefined> => {\n    return value !== undefined && value !== null;\n};\n\nexport const isString = (value: any): value is string => {\n    return typeof value === 'string';\n};\n\nexport const isStringWithValue = (value: any): value is string => {\n    return isString(value) && value !== '';\n};\n\nexport const isBlob = (value: any): value is Blob => {\n    return (\n        typeof value === 'object' &&\n        typeof value.type === 'string' &&\n        typeof value.stream === 'function' &&\n        typeof value.arrayBuffer === 'function' &&\n        typeof value.constructor === 'function' &&\n        typeof value.constructor.name === 'string' &&\n        /^(Blob|File)$/.test(value.constructor.name) &&\n        /^(Blob|File)$/.test(value[Symbol.toStringTag])\n    );\n};\n\nexport const isFormData = (value: any): value is FormData => {\n    return value instanceof FormData;\n};\n\nexport const isSuccess = (status: number): boolean => {\n    return status >= 200 && status < 300;\n};\n\nexport const base64 = (str: string): string => {\n    try {\n        return btoa(str);\n    } catch (err) {\n        // @ts-ignore\n        return Buffer.from(str).toString('base64');\n    }\n};\n\nexport const getQueryString = (params: Record<string, any>): string => {\n    const qs: string[] = [];\n\n    const append = (key: string, value: any) => {\n        qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);\n    };\n\n    const process = (key: string, value: any) => {\n        if (isDefined(value)) {\n            if (Array.isArray(value)) {\n                value.forEach(v => {\n                    process(key, v);\n                });\n            } else if (typeof value === 'object') {\n                Object.entries(value).forEach(([k, v]) => {\n                    process(`${key}[${k}]`, v);\n                });\n            } else {\n                append(key, value);\n            }\n        }\n    };\n\n    Object.entries(params).forEach(([key, value]) => {\n        process(key, value);\n    });\n\n    if (qs.length > 0) {\n        return `?${qs.join('&')}`;\n    }\n\n    return '';\n};\n\nconst getUrl = (config: OpenAPIConfig, options: ApiRequestOptions): string => {\n    const encoder = config.ENCODE_PATH || encodeURI;\n\n    const path = options.url\n        .replace('{api-version}', config.VERSION)\n        .replace(/{(.*?)}/g, (substring: string, group: string) => {\n            if (options.path?.hasOwnProperty(group)) {\n                return encoder(String(options.path[group]));\n            }\n            return substring;\n        });\n\n    const url = `${config.BASE}${path}`;\n    if (options.query) {\n        return `${url}${getQueryString(options.query)}`;\n    }\n    return url;\n};\n\nexport const getFormData = (options: ApiRequestOptions): FormData | undefined => {\n    if (options.formData) {\n        const formData = new FormData();\n\n        const process = (key: string, value: any) => {\n            if (isString(value) || isBlob(value)) {\n                formData.append(key, value);\n            } else {\n                formData.append(key, JSON.stringify(value));\n            }\n        };\n\n        Object.entries(options.formData)\n            .filter(([_, value]) => isDefined(value))\n            .forEach(([key, value]) => {\n                if (Array.isArray(value)) {\n                    value.forEach(v => process(key, v));\n                } else {\n                    process(key, value);\n                }\n            });\n\n        return formData;\n    }\n    return undefined;\n};\n\ntype Resolver<T> = (options: ApiRequestOptions) => Promise<T>;\n\nexport const resolve = async <T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> => {\n    if (typeof resolver === 'function') {\n        return (resolver as Resolver<T>)(options);\n    }\n    return resolver;\n};\n\nexport const getHeaders = async (config: OpenAPIConfig, options: ApiRequestOptions, formData?: FormData): Promise<Record<string, string>> => {\n    const [token, username, password, additionalHeaders] = await Promise.all([\n        resolve(options, config.TOKEN),\n        resolve(options, config.USERNAME),\n        resolve(options, config.PASSWORD),\n        resolve(options, config.HEADERS),\n    ]);\n\n    const formHeaders = typeof formData?.getHeaders === 'function' && formData?.getHeaders() || {}\n\n    const headers = Object.entries({\n        Accept: 'application/json',\n        ...additionalHeaders,\n        ...options.headers,\n        ...formHeaders,\n    })\n    .filter(([_, value]) => isDefined(value))\n    .reduce((headers, [key, value]) => ({\n        ...headers,\n        [key]: String(value),\n    }), {} as Record<string, string>);\n\n    if (isStringWithValue(token)) {\n        headers['Authorization'] = `Bearer ${token}`;\n    }\n\n    if (isStringWithValue(username) && isStringWithValue(password)) {\n        const credentials = base64(`${username}:${password}`);\n        headers['Authorization'] = `Basic ${credentials}`;\n    }\n\n    if (options.body !== undefined) {\n        if (options.mediaType) {\n            headers['Content-Type'] = options.mediaType;\n        } else if (isBlob(options.body)) {\n            headers['Content-Type'] = options.body.type || 'application/octet-stream';\n        } else if (isString(options.body)) {\n            headers['Content-Type'] = 'text/plain';\n        } else if (!isFormData(options.body)) {\n            headers['Content-Type'] = 'application/json';\n        }\n    }\n\n    return headers;\n};\n\nexport const getRequestBody = (options: ApiRequestOptions): any => {\n    if (options.body) {\n        return options.body;\n    }\n    return undefined;\n};\n\nexport const sendRequest = async <T>(\n    config: OpenAPIConfig,\n    options: ApiRequestOptions,\n    url: string,\n    body: any,\n    formData: FormData | undefined,\n    headers: Record<string, string>,\n    onCancel: OnCancel,\n    axiosClient: AxiosInstance\n): Promise<AxiosResponse<T>> => {\n    const source = axios.CancelToken.source();\n\n    const requestConfig: AxiosRequestConfig = {\n        url,\n        headers,\n        data: body ?? formData,\n        method: options.method,\n        withCredentials: config.WITH_CREDENTIALS,\n        withXSRFToken: config.CREDENTIALS === 'include' ? config.WITH_CREDENTIALS : false,\n        cancelToken: source.token,\n    };\n\n    onCancel(() => source.cancel('The user aborted a request.'));\n\n    try {\n        return await axiosClient.request(requestConfig);\n    } catch (error) {\n        const axiosError = error as AxiosError<T>;\n        if (axiosError.response) {\n            return axiosError.response;\n        }\n        throw error;\n    }\n};\n\nexport const getResponseHeader = (response: AxiosResponse<any>, responseHeader?: string): string | undefined => {\n    if (responseHeader) {\n        const content = response.headers[responseHeader];\n        if (isString(content)) {\n            return content;\n        }\n    }\n    return undefined;\n};\n\nexport const getResponseBody = (response: AxiosResponse<any>): any => {\n    if (response.status !== 204) {\n        return response.data;\n    }\n    return undefined;\n};\n\nexport const catchErrorCodes = (options: ApiRequestOptions, result: ApiResult): void => {\n    const errors: Record<number, string> = {\n        400: 'Bad Request',\n        401: 'Unauthorized',\n        403: 'Forbidden',\n        404: 'Not Found',\n        500: 'Internal Server Error',\n        502: 'Bad Gateway',\n        503: 'Service Unavailable',\n        ...options.errors,\n    }\n\n    const error = errors[result.status];\n    if (error) {\n        throw new ApiError(options, result, error);\n    }\n\n    if (!result.ok) {\n        const errorStatus = result.status ?? 'unknown';\n        const errorStatusText = result.statusText ?? 'unknown';\n        const errorBody = (() => {\n            try {\n                return JSON.stringify(result.body, null, 2);\n            } catch (e) {\n                return undefined;\n            }\n        })();\n\n        throw new ApiError(options, result,\n            `Generic Error: status: ${errorStatus}; status text: ${errorStatusText}; body: ${errorBody}`\n        );\n    }\n};\n\n/**\n * Request method\n * @param config The OpenAPI configuration object\n * @param options The request options from the service\n * @param axiosClient The axios client instance to use\n * @returns CancelablePromise<T>\n * @throws ApiError\n */\nexport const request = <T>(config: OpenAPIConfig, options: ApiRequestOptions, axiosClient: AxiosInstance = axios): CancelablePromise<T> => {\n    return new CancelablePromise(async (resolve, reject, onCancel) => {\n        try {\n            const url = getUrl(config, options);\n            const formData = getFormData(options);\n            const body = getRequestBody(options);\n            const headers = await getHeaders(config, options, formData);\n\n            if (!onCancel.isCancelled) {\n                const response = await sendRequest<T>(config, options, url, body, formData, headers, onCancel, axiosClient);\n                const responseBody = getResponseBody(response);\n                const responseHeader = getResponseHeader(response, options.responseHeader);\n\n                const result: ApiResult = {\n                    url,\n                    ok: isSuccess(response.status),\n                    status: response.status,\n                    statusText: response.statusText,\n                    body: responseHeader ?? responseBody,\n                };\n\n                catchErrorCodes(options, result);\n\n                resolve(result.body);\n            }\n        } catch (error) {\n            reject(error);\n        }\n    });\n};\n"
        ],
        "mappings": "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",
        "names": [
          "headers",
          "resolve"
        ]
      }
    },
    {
      "name": "vite:json",
      "start": 1713208780263,
      "end": 1713208780263,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1713208780263,
      "end": 1713208780263,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1713208780263,
      "end": 1713208780263,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1713208780263,
      "end": 1713208780263,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713208780263,
      "end": 1713208780263,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713208780263,
      "end": 1713208780263,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1713208780263,
      "end": 1713208780263,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1713208780263,
      "end": 1713208780263,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1713208780263,
      "end": 1713208780263,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713208780263,
      "end": 1713208780263,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1713208780263,
      "end": 1713208780264,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1713208780264,
      "end": 1713208780265,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1713208780265,
      "end": 1713208780265,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1713208780265,
      "end": 1713208780265,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1713208780265,
      "end": 1713208780265,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1713208780265,
      "end": 1713208780265,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1713208780265,
      "end": 1713208780265,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1713208780265,
      "end": 1713208780265,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1713208780265,
      "end": 1713208780265,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1713208780265,
      "end": 1713208780265,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1713208780265,
      "end": 1713208780265,
      "order": "post"
    },
    {
      "name": "unhead:remove-server-composables",
      "start": 1713208780265,
      "end": 1713208780265,
      "order": "post"
    },
    {
      "name": "unhead:use-seo-meta-transform",
      "start": 1713208780265,
      "end": 1713208780265,
      "order": "post"
    },
    {
      "name": "unhead:use-seo-meta-transform",
      "start": 1713208780265,
      "end": 1713208780265,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-resource",
      "start": 1713208780265,
      "end": 1713208780265,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-resource",
      "start": 1713208780265,
      "end": 1713208780265,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-meta-deprecation",
      "start": 1713208780265,
      "end": 1713208780265,
      "order": "post"
    },
    {
      "name": "nuxtjs:i18n-meta-deprecation",
      "start": 1713208780265,
      "end": 1713208780265,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1713208780265,
      "end": 1713208780272,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1713208780265,
      "end": 1713208780272,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1713208780272,
      "end": 1713208780272,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1713208780272,
      "end": 1713208780272,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1713208780272,
      "end": 1713208780272,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1713208780272,
      "end": 1713208780272,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1713208780272,
      "end": 1713208780272,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1713208780272,
      "end": 1713208780272,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1713208780272,
      "end": 1713208780272,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1713208780272,
      "end": 1713208780273,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1713208780273,
      "end": 1713208780273,
      "order": "normal"
    }
  ]
}
